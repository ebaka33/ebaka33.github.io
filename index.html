<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>CatInn Tycoon — Отель котика</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Милый шрифт -->
  <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin:0; padding:0; background:#0e0f16; height:100%;
      font-family: 'Comfortaa', system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color:#f5f7ff; overflow:hidden;
    }
    #ui {
      position:fixed; left:0; right:0; top:0; padding:8px 12px;
      display:flex; gap:8px; align-items:center; justify-content:space-between;
      background:linear-gradient(180deg, rgba(12,14,22,0.9), rgba(12,14,22,0.6));
      backdrop-filter: blur(6px); border-bottom:1px solid rgba(255,255,255,0.06); z-index:10;
    }
    .panel {
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
    }
    .pill {
      background: rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.12);
      border-radius: 12px; padding:6px 10px; font-weight:600;
    }
    button {
      background: linear-gradient(180deg, #ffd26b, #ff9c2b);
      color:#3a2200; border:none; border-radius:10px; padding:8px 12px;
      font-weight:700; cursor:pointer; box-shadow:0 2px 0 rgba(0,0,0,0.2);
    }
    button.secondary {
      background: linear-gradient(180deg, #a7b6ff, #7a8cff); color:#0b0e1a;
    }
    button.ghost {
      background: transparent; color:#ffd26b; border:1px solid #ffd26b;
    }
    #game { display:block; width:100vw; height:100vh; }
    #dialog {
      position:fixed; left:50%; top:80px; transform:translateX(-50%);
      background:linear-gradient(180deg, rgba(28,31,48,0.96), rgba(20,23,38,0.96));
      border:1px solid rgba(255,255,255,0.14); border-radius:14px; padding:16px 18px; max-width:720px; z-index:20;
      display:none;
    }
    #dialog h3 { margin:0 0 8px 0; font-size:18px; }
    #dialog p { margin:0 0 8px 0; line-height:1.5; }
    #tooltip {
      position:fixed; pointer-events:none; background:rgba(20,22,36,0.95);
      border:1px solid rgba(255,255,255,0.12); border-radius:8px; padding:6px 8px; font-size:12px;
      display:none; z-index:30;
    }
    #bottom {
      position:fixed; left:0; right:0; bottom:8px; display:flex; justify-content:center; gap:8px; z-index:9;
    }
    .card {
      background:rgba(17,19,30,0.9); border:1px solid rgba(255,255,255,0.10);
      border-radius:12px; padding:8px 10px; display:flex; gap:8px; align-items:center;
    }
    .small { font-size:12px; opacity:0.9; }
    .money { color:#ffd26b; }
    .rep { color:#9ee7ff; }
    .vip { color:#ff9ac8; }
    a.link { color:#a7b6ff; text-decoration:none; border-bottom:1px dotted #a7b6ff; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="panel">
      <div class="pill">День: <span id="day">1</span></div>
      <div class="pill">Время: <span id="time">08:00</span></div>
      <div class="pill money">Монеты: <span id="money">0</span></div>
      <div class="pill rep">Репутация: <span id="rep">1.0★</span></div>
      <div class="pill">Гости: <span id="guests">0</span>/<span id="capacity">0</span></div>
    </div>
    <div class="panel">
      <button id="btnStart">Начать день</button>
      <button id="btnSpeed">Скорость x1</button>
      <button id="btnBuild" class="secondary">Построить этаж</button>
      <button id="btnHire" class="secondary">Нанять персонал</button>
      <button id="btnFurniture" class="secondary">Мебель</button>
      <button id="btnSave" class="ghost">Сохранить</button>
      <button id="btnLoad" class="ghost">Загрузить</button>
    </div>
  </div>

  <div id="dialog">
    <h3 id="dlgTitle">Письмо от дяди Кота</h3>
    <p id="dlgText">...</p>
    <div style="display:flex; gap:8px; justify-content:flex-end;">
      <button id="dlgNext">Далее</button>
    </div>
  </div>

  <div id="bottom">
    <div class="card small">Подсказка: начни с 2 номеров и администратора. Чистоту держит горничная.</div>
  </div>

  <div id="tooltip"></div>

  <canvas id="game"></canvas>

  <script>
  ;(() => {
    // ========= Helpers =========
    const TAU = Math.PI * 2;
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp = (a,b,t)=>a+(b-a)*t;
    const ease = t => t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;
    const rand = (a=1,b=0)=>Math.random()*(a-b)+b;
    const randi = (a,b)=>Math.floor(rand(a+1,b));
    const choice = arr => arr[Math.floor(Math.random()*arr.length)];
    const now = () => performance.now();

    // Currency formatting
    const fmt = (n) => {
      if (n < 1e3) return ""+Math.floor(n);
      if (n < 1e6) return (n/1e3).toFixed(1)+"K";
      if (n < 1e9) return (n/1e6).toFixed(1)+"M";
      return (n/1e9).toFixed(1)+"B";
    };

    // ========= Canvas =========
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const resize = () => {
      canvas.width = Math.floor(window.innerWidth * DPR);
      canvas.height = Math.floor(window.innerHeight * DPR);
      canvas.style.width = window.innerWidth+"px";
      canvas.style.height = window.innerHeight+"px";
      ctx.setTransform(DPR,0,0,DPR,0,0);
    };
    window.addEventListener('resize', resize);
    resize();

    // ========= UI Elements =========
    const ui = {
      day: document.getElementById('day'),
      time: document.getElementById('time'),
      money: document.getElementById('money'),
      rep: document.getElementById('rep'),
      guests: document.getElementById('guests'),
      capacity: document.getElementById('capacity'),
      dialog: document.getElementById('dialog'),
      dlgTitle: document.getElementById('dlgTitle'),
      dlgText: document.getElementById('dlgText'),
      dlgNext: document.getElementById('dlgNext'),
      tooltip: document.getElementById('tooltip'),
      btnStart: document.getElementById('btnStart'),
      btnSpeed: document.getElementById('btnSpeed'),
      btnBuild: document.getElementById('btnBuild'),
      btnHire: document.getElementById('btnHire'),
      btnFurniture: document.getElementById('btnFurniture'),
      btnSave: document.getElementById('btnSave'),
      btnLoad: document.getElementById('btnLoad'),
    };

    // ========= Game State =========
    const G = {
      money: 250,
      rep: 1.0, // 1..5
      day: 1,
      time: 8*60, // minutes in day, 0..24*60
      dayLengthSec: 120, // realtime seconds at x1 per day
      speed: 1,
      running: false,
      floors: [],
      guests: [],
      staff: [],
      effects: [],
      floaters: [],
      dialogs: [],
      event: null,
      lastTick: now(),
      seed: Math.floor(Math.random()*1e9),
    };

    // Offline progress
    const SAVE_KEY = 'catinn_save_v1';
    const save = () => {
      const data = {
        money:G.money, rep:G.rep, day:G.day, time:G.time, speed:1, running:false,
        floors:G.floors, staff:G.staff, seed:G.seed, last:Date.now()
      };
      localStorage.setItem(SAVE_KEY, JSON.stringify(data));
      popup("Сохранено");
    };
    const load = () => {
      const s = localStorage.getItem(SAVE_KEY);
      if (!s) { popup("Сохранений нет"); return; }
      try {
        const d = JSON.parse(s);
        Object.assign(G, d);
        // revive methods
        G.floors.forEach(f => reviveFloor(f));
        G.staff.forEach(st => st.state = st.state || 'idle');
        // offline earnings
        const deltaMin = Math.min(12*60, Math.floor((Date.now() - (d.last||Date.now()))/60000));
        const offline = Math.floor(deltaMin * passiveIncomePerMin());
        if (offline>0) {
          G.money += offline;
          popup(`Пока тебя не было, отель заработал +${fmt(offline)}`);
        }
        popup("Загружено");
      } catch(e) {
        popup("Ошибка загрузки");
      }
    };

    // ========= Economy & Progression =========
    const FurnitureTiers = [
      {name:'Старьё', mult:1.0, color:'#8c7b6b', price: 0},
      {name:'Уютно', mult:1.25, color:'#bfa08a', price: 150},
      {name:'Стильно', mult:1.6, color:'#c6d6ff', price: 450},
      {name:'Люкс', mult:2.1, color:'#ffd26b', price: 1200},
      {name:'Футуризм', mult:2.9, color:'#9ee7ff', price: 3000},
    ];

    function roomBasePrice(tierIndex) {
      return Math.floor(30 * Math.pow(1.25, tierIndex)); // per guest cycle
    }
    function buildFloorCost(idx) {
      return Math.floor(400 * Math.pow(1.6, idx)); // increases per floor
    }
    function hireCost(role, countOwned) {
      const base = {reception:150, maid:200, bell:180, mech:220}[role] || 150;
      return Math.floor(base * Math.pow(1.35, countOwned));
    }
    function passiveIncomePerMin() {
      // rough estimation of income if running
      let cap = capacity();
      let avg = 20 + 5*G.rep + 10*Math.log2(1+cap);
      return Math.floor((cap*avg)/20);
    }

    // ========= Building Model =========
    function makeRoom(id, roomIndex){
      return {
        id, idx:roomIndex, tier:0, occupied:false, guestId:null,
        dirty:0, // 0..100
        x: 2 + (roomIndex%4)*3,
        y: 1 + Math.floor(roomIndex/4)*3,
        w: 2, h:2,
      };
    }
    function makeFloor(index){
      const rooms = [];
      const roomCount = 6 + (index>0 ? 2 : 0); // later floors bigger
      for (let i=0;i<roomCount;i++) rooms.push(makeRoom(`F${index}R${i}`, i));
      const floor = {
        index,
        rooms,
        elevatorX: 0,
        corridorY: 0,
        baseX: 0, baseY: 0, // dynamic layout calc
      };
      reviveFloor(floor);
      return floor;
    }
    function reviveFloor(floor){
      // layout: corridor at y=0 line, elevator at x=0
      floor.baseX = 0; floor.baseY = 0;
      floor.rooms.forEach((r,i)=>{
        r.x = 2 + (i%4)*3;
        r.y = 1 + Math.floor(i/4)*3;
      });
    }
    function capacity(){
      let cap=0;
      G.floors.forEach(f => f.rooms.forEach(r => cap++));
      return cap;
    }

    // ========= Staff =========
    function addStaff(role){
      const s = {
        id:'S'+Math.floor(Math.random()*1e6),
        role, x: -2, y: 0, floor:0, state:'idle', target:null, t:0,
        speed: role==='bell'? 1.3 : role==='maid'? 1.1 : 1.0,
      };
      G.staff.push(s);
      return s;
    }

    // ========= Guests =========
    function spawnGuest(){
      const g = {
        id:'G'+Math.floor(Math.random()*1e6),
        mood: 0.5, // 0..1
        wallet: 40 + rand(50,20)*G.rep,
        vip: Math.random()< (0.08 + (G.rep-1)*0.04),
        x: -4, y: 0, floor:0, state:'arrival', t:0, room:null, color: choice(['#ffcc88','#ffc0cb','#c0ffee','#c8a2c8','#fff1a8']),
        speed: 1.0
      };
      if (g.vip) g.wallet *= 2.2;
      G.guests.push(g);
      return g;
    }

    // ========= Dialog System =========
    const tutorialDialogs = [
      {title:'Письмо от дяди Кота', text:'Племяш, держи мой отель! Старенький, но с душой. Заселяй котов, чини мебель и не забудь улыбаться усами.'},
      {title:'Совет', text:'Построй первый этаж и два номера. Нанимай администратора — он встречает гостей и ускоряет заселение.'},
      {title:'Подсказка', text:'Улучшай мебель: чем выше стиль — тем больше платят и растёт репутация.'},
    ];
    function queueDialog(title, text){
      G.dialogs.push({title, text});
      showNextDialog();
    }
    function showNextDialog(){
      if (ui.dialog.style.display === 'block') return;
      const d = G.dialogs.shift();
      if (!d) return;
      ui.dlgTitle.textContent = d.title;
      ui.dlgText.textContent = d.text;
      ui.dialog.style.display = 'block';
    }
    ui.dlgNext.addEventListener('click', ()=>{
      ui.dialog.style.display = 'none';
      showNextDialog();
    });

    // ========= UI Buttons =========
    ui.btnStart.addEventListener('click', ()=>{
      if (G.floors.length===0){
        queueDialog('Нужно построить!', 'Сначала построй хотя бы один этаж.');
        return;
      }
      G.running = !G.running;
      ui.btnStart.textContent = G.running ? 'Пауза' : 'Начать день';
      if (G.running && G.time>=24*60) G.time = 8*60;
    });
    ui.btnSpeed.addEventListener('click', ()=>{
      G.speed = (G.speed===1)?2:(G.speed===2)?4:1;
      ui.btnSpeed.textContent = `Скорость x${G.speed}`;
    });
    ui.btnBuild.addEventListener('click', ()=>{
      const idx = G.floors.length;
      const cost = buildFloorCost(idx);
      confirmDialog('Строительство', `Построить этаж #${idx+1} за ${fmt(cost)}?`, ()=>{
        if (G.money<cost){ popup('Недостаточно монет'); return; }
        G.money -= cost;
        G.floors.push(makeFloor(idx));
        popup(`Этаж #${idx+1} готов!`);
        if (idx===0) {
          // give starter staff
          addStaff('reception');
          popup('Администратор принят на работу!');
        }
      });
    });
    ui.btnHire.addEventListener('click', ()=>{
      // simple modal with options
      const roles = [
        {key:'reception', name:'Администратор'},
        {key:'maid', name:'Горничная'},
        {key:'bell', name:'Носильщик'},
        {key:'mech', name:'Механик'},
      ];
      const counts = (role)=>G.staff.filter(s=>s.role===role).length;
      let text = 'Кого нанимаем?\n';
      roles.forEach(r=>{
        text += `• ${r.name} — ${fmt(hireCost(r.key, counts(r.key)))}\n`;
      });
      choiceDialog('Найм персонала', text, roles.map(r=>({
        label:`${r.name} (${fmt(hireCost(r.key, counts(r.key)))})`,
        cb: ()=>{
          const cost = hireCost(r.key, counts(r.key));
          if (G.money<cost){ popup('Недостаточно монет'); return; }
          G.money -= cost;
          addStaff(r.key);
          popup(`${r.name} нанят(а)!`);
        }
      })));
    });
    ui.btnFurniture.addEventListener('click', ()=>{
      // Upgrade random room or manage
      if (G.floors.length===0){ popup('Нет этажей'); return; }
      const allRooms = G.floors.flatMap(f=>f.rooms);
      const selectable = allRooms.filter(r=>r.tier < FurnitureTiers.length-1);
      if (selectable.length===0){ popup('Вся мебель уже топ!'); return; }
      const r = choice(selectable);
      const nextTier = r.tier+1;
      const cost = FurnitureTiers[nextTier].price;
      confirmDialog('Улучшение мебели', `Комната ${r.id}: улучшить с «${FurnitureTiers[r.tier].name}» до «${FurnitureTiers[nextTier].name}» за ${fmt(cost)}?`, ()=>{
        if (G.money<cost){ popup('Недостаточно монет'); return; }
        G.money -= cost; r.tier = nextTier; r.dirty = Math.max(0, r.dirty-20);
        popup(`Комната ${r.id} стала «${FurnitureTiers[nextTier].name}»!`);
        G.rep = clamp(G.rep + 0.05, 1, 5);
      });
    });
    ui.btnSave.addEventListener('click', save);
    ui.btnLoad.addEventListener('click', load);

    // ========= Simple Modal Helpers =========
    function popup(text, t=1800){
      G.floaters.push({x: window.innerWidth/2, y: 56, text, t, vy:-0.2, alpha:1});
    }
    function confirmDialog(title, text, onYes){
      G.dialogs.unshift({title, text:text + '\n\nНажми «Далее» для подтверждения.'});
      showNextDialog();
      const oldNext = ui.dlgNext.onclick;
      ui.dlgNext.onclick = ()=>{ ui.dlgNext.onclick = oldNext; ui.dialog.style.display='none'; onYes(); };
    }
    function choiceDialog(title, text, options){
      // quick and simple: first dialog shows text, next replaces with choices
      G.dialogs.unshift({title, text});
      showNextDialog();
      const oldNext = ui.dlgNext.onclick;
      ui.dlgNext.onclick = ()=> {
        ui.dlgNext.onclick = oldNext;
        // build temporary choice panel
        ui.dlgTitle.textContent = title;
        ui.dlgText.innerHTML = options.map((o,i)=>`<button id="opt${i}" style="margin:4px 6px;" class="secondary">${o.label}</button>`).join('');
        ui.dialog.style.display='block';
        options.forEach((o,i)=>{
          document.getElementById('opt'+i).onclick = ()=>{ ui.dialog.style.display='none'; o.cb(); };
        });
      };
    }

    // Initial dialogs
    tutorialDialogs.forEach(d => queueDialog(d.title, d.text));

    // ========= Time & Loop =========
    function updateUI(){
      ui.day.textContent = G.day;
      const hh = Math.floor(G.time/60)%24;
      const mm = Math.floor(G.time%60);
      ui.time.textContent = `${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}`;
      ui.money.textContent = fmt(G.money);
      ui.rep.textContent = `${G.rep.toFixed(1)}★`;
      ui.guests.textContent = G.guests.length;
      ui.capacity.textContent = capacity();
    }

    function advance(dt){
      // dt in seconds real-time
      const dayMinutesPerSecond = (24*60) / G.dayLengthSec;
      const gameMinutes = dt * dayMinutesPerSecond * G.speed;
      if (G.running) G.time += gameMinutes;
      if (G.time >= 24*60) {
        G.time = 8*60; G.day++;
        // daily events
        dailyEventRoll();
        // small upkeep: if too dirty, rep drops
        const avgDirty = avgRoomsDirty();
        if (avgDirty>40) G.rep = Math.max(1, G.rep - 0.1);
      }

      // spawn guests if running, in daytime
      const hh = Math.floor(G.time/60)%24;
      const arrivalFactor = (hh>=8 && hh<=22) ? 1 : 0.1;
      const flow = (0.2 + 0.12 * (G.rep-1)) * arrivalFactor * G.speed;
      G._spawnTimer = (G._spawnTimer || 0) + dt * flow;
      if (G._spawnTimer>1) { G._spawnTimer=0; if (G.running) trySpawnGuest(); }

      // update guests & staff
      G.guests.forEach(g=>updateGuest(g, dt));
      G.staff.forEach(s=>updateStaff(s, dt));

      // effects
      G.floaters = G.floaters.filter(f=> (f.t-=dt*1000) > 0).map(f=>{
        f.y += f.vy * 16; f.alpha = Math.max(0, f.t/1800); return f;
      });

      // auto-clean a bit each night
      if (!G.running && (hh>=0 && hh<6)) {
        G.floors.forEach(f=>f.rooms.forEach(r=>r.dirty=Math.max(0, r.dirty-0.02*dt*60)));
      }
    }

    function avgRoomsDirty(){
      const rooms = G.floors.flatMap(f=>f.rooms);
      if (rooms.length===0) return 0;
      return rooms.reduce((a,r)=>a+r.dirty,0)/rooms.length;
    }

    function trySpawnGuest(){
      if (G.guests.length >= capacity()) return;
      const g = spawnGuest();
      // path: entrance (-4,0) -> reception (0,0) -> elevator (0,0) -> room door
      g.state = 'arrival';
    }

    // ========= Guest Logic =========
    function updateGuest(g, dt){
      g.t += dt;
      const speed = 1.2 * g.speed;

      if (g.state==='arrival'){
        moveTo(g, 0, 0, dt, speed);
        if (dist(g.x,g.y,0,0) < 0.2){
          // reception check
          const adminCount = G.staff.filter(s=>s.role==='reception').length;
          const wait = Math.max(0.5, 2.5 - 0.6*adminCount);
          if (!g._timer) g._timer = wait;
          g._timer -= dt;
          if (g._timer<=0){
            // try assign room
            const room = pickRoomForGuest(g);
            if (room){
              g.room = room;
              room.occupied = true; room.guestId = g.id;
              g.state = 'toElevator';
              g._timer = null;
              // bellhop bonus
              const bell = G.staff.some(s=>s.role==='bell');
              if (bell) g.mood = clamp(g.mood+0.1,0,1);
            } else {
              // no room — leave sad
              g.state='leave'; g.mood = Math.max(0.2, g.mood-0.3);
            }
          }
        }
      } else if (g.state==='toElevator'){
        moveTo(g, 0.2, 0, dt, speed);
        if (near(g,0.2,0)) g.state='toRoom';
      } else if (g.state==='toRoom'){
        const target = doorIsoPos(g.room, g.roomFloor || findRoomFloor(g.room));
        moveTo(g, target.x, target.y, dt, speed*1.1);
        if (near(g, target.x, target.y)){
          g.state = 'stay';
          g._stay = 20 + rand(25,10)*FurnitureTiers[g.room.tier].mult; // minutes
        }
      } else if (g.state==='stay'){
        // enjoy room, generate revenue
        if (!g._paid){
          const base = roomBasePrice(g.room.tier);
          const cleanliness = 1 - (g.room.dirty/100);
          const pay = Math.floor(base * (0.8 + 0.4*G.rep/5) * cleanliness * (g.vip?1.8:1));
          earn(pay, `Оплата номера ${g.room.id}${g.vip?' (VIP)':''}`, doorScreenPos(g.room));
          g._paid = true;
          g.mood = clamp(g.mood + 0.15 + 0.1*(FurnitureTiers[g.room.tier].mult-1), 0, 1);
          g.room.dirty = clamp(g.room.dirty + rand(20,10), 0, 100);
        }
        g._stay -= dt * (24*60 / G.dayLengthSec) * G.speed; // convert to game minutes drain
        if (g._stay<=0){
          g.state='leave';
          // reputation tweak
          if (g.mood > 0.6) G.rep = clamp(G.rep + (g.vip?0.05:0.02), 1, 5);
          else G.rep = clamp(G.rep - 0.02, 1, 5);
          // free room
          if (g.room){ g.room.occupied=false; g.room.guestId=null; }
        }
      } else if (g.state==='leave'){
        moveTo(g, -6, 0, dt, speed*1.2);
        if (g.x < -5.5){
          // despawn
          const idx = G.guests.indexOf(g);
          if (idx>=0) G.guests.splice(idx,1);
        }
      }
    }
    function pickRoomForGuest(g){
      const rooms = G.floors.flatMap((f,fi)=>f.rooms.map(r=>({r,floor:fi})));
      const free = rooms.filter(o=>!o.r.occupied);
      if (free.length===0) return null;
      // prefer higher tier and cleaner
      free.sort((a,b)=>{
        const av = a.r.tier*100 - a.r.dirty;
        const bv = b.r.tier*100 - b.r.dirty;
        return bv - av;
      });
      const pick = free[0];
      g.roomFloor = pick.floor;
      return pick.r;
    }

    // ========= Staff Logic =========
    function updateStaff(s, dt){
      s.t += dt;
      const speed = 1.0 * (s.speed||1);
      if (s.role==='reception'){
        // stand near (0,0)
        moveTo(s, -0.2, 0, dt, speed*0.9);
      } else if (s.role==='maid'){
        // find dirtiest free room
        if (!s.target || s.target.occupied || s.target.dirty<=5){
          const rooms = G.floors.flatMap(f=>f.rooms);
          const target = rooms.filter(r=>!r.occupied).sort((a,b)=>b.dirty-a.dirty)[0];
          s.target = target||null;
        }
        if (s.target){
          const pos = doorIsoPos(s.target, findRoomFloor(s.target));
          moveTo(s, pos.x-0.2, pos.y, dt, speed*1.1);
          if (near(s, pos.x-0.2, pos.y)){
            // clean over time
            s.target.dirty = Math.max(0, s.target.dirty - dt*8);
          }
        }
      } else if (s.role==='bell'){
        // escort VIPs slightly (visual)
        const vip = G.guests.find(g=>g.vip && (g.state==='toRoom' || g.state==='arrival'));
        if (vip){
          moveTo(s, vip.x-0.3, vip.y, dt, speed*1.2);
        } else {
          moveTo(s, 0.2, 0, dt, speed);
        }
      } else if (s.role==='mech'){
        // reduce breakdown chance (here: just wander and "fix")
        if (!s._wander){ s._wander = {x: rand(6, -2), y: rand(4, -1)}; }
        moveTo(s, s._wander.x, s._wander.y, dt, speed);
        if (near(s, s._wander.x, s._wander.y)) s._wander = null;
      }
    }

    function findRoomFloor(room){
      for (let i=0;i<G.floors.length;i++){
        if (G.floors[i].rooms.includes(room)) return i;
      }
      return 0;
    }

    function moveTo(obj, tx, ty, dt, spd){
      const dx = tx - obj.x, dy = ty - obj.y;
      const d = Math.hypot(dx,dy);
      if (d<0.01) return;
      const v = spd * dt;
      if (v >= d){ obj.x = tx; obj.y = ty; }
      else { obj.x += dx/d * v; obj.y += dy/d * v; }
    }
    function dist(a,b,x,y){ return Math.hypot(a-x,b-y); }
    function near(o,x,y){ return dist(o.x,o.y,x,y) < 0.15; }

    // ========= World Coords & Drawing =========
    const TILE_W = 64, TILE_H = 36; // iso projection base
    function iso(x,y,z=0){
      // isometric projection
      const sx = (x - y) * (TILE_W/2);
      const sy = (x + y) * (TILE_H/2) - z*24;
      return {x:sx, y:sy};
    }
    function worldToScreen(x,y, floorIdx=0){
      const p = iso(x,y,floorIdx);
      // center building
      const cx = canvas.width/DPR/2;
      const baseY = canvas.height/DPR - 140 - floorIdx*80;
      return {x: cx + p.x, y: baseY + p.y};
    }

    function doorIsoPos(room, floorIdx){
      // door at front side of room
      const x = room.x + room.w/2;
      const y = room.y + room.h + 0.2;
      return {x, y};
    }
    function doorScreenPos(room){
      const p = doorIsoPos(room, findRoomFloor(room));
      return worldToScreen(p.x, p.y, findRoomFloor(room));
    }

    function drawBackground(t){
      const w = canvas.width/DPR, h = canvas.height/DPR;
      // sky gradient changes with time
      const dayT = ((Math.floor(G.time)% (24*60))/ (24*60));
      const sky1 = dayT>0.2 && dayT<0.8 ? '#75b6ff' : '#101520';
      const sky2 = dayT>0.2 && dayT<0.8 ? '#e9f3ff' : '#0b0f1a';
      const grd = ctx.createLinearGradient(0,0,0,h);
      grd.addColorStop(0, sky2);
      grd.addColorStop(1, sky1);
      ctx.fillStyle = grd;
      ctx.fillRect(0,0,w,h);

      // sun / moon
      const angle = dayT * TAU;
      const sx = w*0.1 + Math.cos(angle - Math.PI/2)*w*0.4;
      const sy = h*0.5 + Math.sin(angle - Math.PI/2)*h*0.3;
      ctx.beginPath();
      ctx.arc(sx, sy, 30, 0, TAU);
      ctx.fillStyle = dayT>0.2 && dayT<0.8 ? '#fff3a3' : '#dbe5ff';
      ctx.globalAlpha = 0.9;
      ctx.fill(); ctx.globalAlpha = 1;

      // parallax clouds
      for (let i=0;i<6;i++){
        const cx = (t*0.02*i*30 + i*200) % (w+200) - 100;
        const cy = 80 + i*24 + Math.sin(t*0.001*i)*4;
        ctx.fillStyle = 'rgba(255,255,255,' + (0.18 + i*0.04) + ')';
        roundedRect(cx, cy, 160, 40, 20, true);
      }

      // skyline
      ctx.fillStyle = '#0f1320';
      for (let i=0;i<14;i++){
        const bx = i * 120 + (Math.sin(i*12.3)*50);
        const bh = 80 + (i%3)*40 + Math.sin(i*2)*10;
        ctx.fillRect(bx, h-220, 80, bh);
      }

      // ground
      ctx.fillStyle = '#1b2033';
      ctx.fillRect(0, h-120, w, 120);
      // grass wiggle
      for (let i=0;i<w;i+=8){
        const gh = 8 + Math.sin(t*0.005 + i*0.1)*3;
        ctx.fillStyle = '#1d2b2a';
        ctx.fillRect(i, h-120-gh, 6, gh);
      }
    }

    function roundedRect(x,y,w,h,r,fill=true,stroke=false){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      if (fill) ctx.fill();
      if (stroke){ ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.stroke(); }
    }

    function drawBuilding(){
      // base platform
      const baseY = canvas.height/DPR - 120;
      ctx.fillStyle = '#2a2f49';
      roundedRect(canvas.width/DPR/2 - 300, baseY, 600, 20, 10, true);

      // draw floors back-to-front
      for (let fi=0; fi<G.floors.length; fi++){
        drawFloor(G.floors[fi], fi);
      }
    }

    function drawFloor(floor, fi){
      // corridor slab
      const left = worldToScreen(-2, 1, fi);
      const right = worldToScreen(20, 1, fi);
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(left.x, left.y);
      ctx.lineTo(right.x, right.y);
      ctx.stroke();

      // elevator shaft
      const eTop = worldToScreen(0, -0.5, fi);
      const eBot = worldToScreen(0, 1.5, fi);
      ctx.fillStyle = '#3b4166';
      roundedRect(eTop.x-10, eTop.y-30, 20, 60, 6, true);
      // doors shimmer
      ctx.fillStyle = '#606896';
      roundedRect(eTop.x-8, eTop.y-22, 16, 44, 4, true);

      // draw rooms
      floor.rooms.forEach(r => drawRoom(r, fi));
    }

    function drawRoom(room, fi){
      const p = worldToScreen(room.x, room.y, fi);
      const w = TILE_W * room.w * 0.9;
      const h = TILE_H * room.h * 0.9;
      // top face (iso-ish)
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.fillStyle = '#2b3150';
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(w*0.5, h*0.5);
      ctx.lineTo(0, h);
      ctx.lineTo(-w*0.5, h*0.5);
      ctx.closePath();
      ctx.fill(); ctx.stroke();

      // furniture color by tier
      const fcol = FurnitureTiers[room.tier].color;
      drawFurniture(room, fcol);

      // door front indicator
      const door = iso(room.x+room.w/2, room.y+room.h+0.2, fi);
      const ds = worldToScreen(room.x+room.w/2, room.y+room.h+0.2, fi);
      ctx.restore();

      // nameplate
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.font = '12px Comfortaa';
      ctx.textAlign='center';
      ctx.fillText(room.id, ds.x, ds.y+10);

      // occupancy light
      ctx.beginPath();
      ctx.arc(ds.x+24, ds.y-6, 4, 0, TAU);
      ctx.fillStyle = room.occupied ? '#ffd26b' : '#58608a';
      ctx.fill();

      // dirt meter
      if (room.dirty>5){
        ctx.fillStyle = 'rgba(255,82,82,0.7)';
        ctx.fillRect(ds.x-28, ds.y+14, 56*(room.dirty/100), 4);
      }
    }

    function drawFurniture(room, color){
      // simple icons: bed + lamp + plant/TV variants by tier
      // draw on current transform origin at room top face center
      ctx.save();
      const p = worldToScreen(room.x, room.y, findRoomFloor(room));
      ctx.translate(p.x, p.y);
      // bed
      ctx.fillStyle = color;
      roundedRect(-18, 10, 36, 12, 6, true);
      ctx.fillStyle = 'white';
      roundedRect(-16, 12, 16, 8, 4, true);
      ctx.fillStyle = '#e9f3ff';
      roundedRect(0, 12, 14, 8, 4, true);
      // lamp
      ctx.fillStyle = '#ffd26b';
      roundedRect(14, 2, 6, 6, 3, true);
      // style extras
      if (room.tier>=1){
        ctx.fillStyle = '#9ee7ff';
        roundedRect(-4, 0, 8, 4, 2, true); // small table
      }
      if (room.tier>=2){
        ctx.fillStyle = '#c6d6ff';
        roundedRect(-26, -2, 10, 6, 3, true); // TV
      }
      if (room.tier>=3){
        ctx.fillStyle = '#a7f3d0';
        roundedRect(20, 8, 6, 10, 3, true); // plant
      }
      if (room.tier>=4){
        ctx.fillStyle = '#ff9ac8';
        roundedRect(-30, 10, 6, 10, 3, true); // neon
      }
      ctx.restore();
    }

    function drawCat(x,y, options={}){
      // cute cat sprite
      const s = options.scale||1;
      ctx.save();
      const p = worldToScreen(x,y, options.floor||0);
      ctx.translate(p.x, p.y - 8);
      const c = options.color || '#ffcfa8';
      const t = options.t || 0;
      // bobbing
      ctx.translate(0, Math.sin(t*4)*1.2);

      // shadow
      ctx.globalAlpha = 0.2;
      ctx.fillStyle = '#000';
      ctx.beginPath(); ctx.ellipse(0, 10, 12, 4, 0, 0, TAU); ctx.fill();
      ctx.globalAlpha = 1;

      // body
      ctx.fillStyle = c;
      roundedRect(-10*s, -2*s, 20*s, 14*s, 7*s, true);
      // head
      roundedRect(-8*s, -12*s, 16*s, 14*s, 7*s, true);
      // ears
      ctx.fillStyle = c;
      ctx.beginPath();
      ctx.moveTo(-6*s,-12*s); ctx.lineTo(-1*s,-16*s); ctx.lineTo(-1*s,-12*s); ctx.fill();
      ctx.beginPath();
      ctx.moveTo(6*s,-12*s); ctx.lineTo(1*s,-16*s); ctx.lineTo(1*s,-12*s); ctx.fill();
      // face
      ctx.fillStyle = '#000';
      ctx.beginPath(); ctx.arc(-3*s, -7*s, 1.5*s, 0, TAU); ctx.fill();
      ctx.beginPath(); ctx.arc(3*s, -7*s, 1.5*s, 0, TAU); ctx.fill();
      ctx.strokeStyle = '#000'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(0,-6*s); ctx.lineTo(0,-4*s); ctx.stroke();
      // whiskers
      ctx.beginPath(); ctx.moveTo(-5*s,-6*s); ctx.lineTo(-9*s,-6.5*s); ctx.moveTo(-5*s,-5*s); ctx.lineTo(-9*s,-5*s);
      ctx.moveTo(5*s,-6*s); ctx.lineTo(9*s,-6.5*s); ctx.moveTo(5*s,-5*s); ctx.lineTo(9*s,-5*s);
      ctx.stroke();

      // tail wag
      ctx.strokeStyle = c; ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10*s, 2*s);
      const wag = Math.sin(t*6)*4*s;
      ctx.quadraticCurveTo(16*s, -4*s, 12*s, -8*s+wag);
      ctx.stroke();

      // role badge if staff
      if (options.badge){
        ctx.fillStyle = options.badgeColor||'#ffd26b';
        ctx.beginPath(); ctx.arc(12*s, -14*s, 4*s, 0, TAU); ctx.fill();
      }
      ctx.restore();
    }

    function drawGuestsAndStaff(t){
      // draw by floor order
      G.staff.forEach(s=>{
        drawCat(s.x, s.y, {floor:s.floor||0, t, color:'#c8e7ff', badge:true, badgeColor: staffBadgeColor(s.role)});
      });
      G.guests.forEach(g=>{
        drawCat(g.x, g.y, {floor:g.floor||0, t, color:g.color});
      });
    }
    function staffBadgeColor(role){
      return {reception:'#ffd26b', maid:'#a7f3d0', bell:'#ff9ac8', mech:'#9ee7ff'}[role] || '#ffd26b';
    }

    // ========= Effects =========
    function earn(amount, label, pos){
      G.money += amount;
      G.floaters.push({x: pos?pos.x:canvas.width/DPR/2, y: pos?pos.y:86, text:`+${fmt(amount)} ${label||''}`, t:2200, vy:-0.12, alpha:1});
    }

    // ========= Events =========
    function dailyEventRoll(){
      const roll = Math.random();
      if (roll < 0.25){
        const ev = choice(['Фестиваль кошачьей мяты', 'Ночная распродажа пледов', 'Выставка когтеточек']);
        queueDialog('Событие дня', `${ev}! Поток гостей выше.`);
        G._eventBoost = 1.4;
      } else {
        G._eventBoost = 1.0;
      }
      if (Math.random()<0.12){
        queueDialog('VIP-ночь', 'Слух прошёл по городу — ожидаются VIP-гости! Доход выше.');
      }
    }

    // ========= Main Loop =========
    function loop(){
      const t = now();
      const dt = Math.min(0.05, (t - G.lastTick)/1000);
      G.lastTick = t;
      advance(dt);
      render(t/1000);
      updateUI();
      requestAnimationFrame(loop);
    }

    function render(t){
      drawBackground(t);
      drawBuilding();
      drawGuestsAndStaff(t);

      // UI floaters
      ctx.save();
      ctx.font = '14px Comfortaa'; ctx.textAlign='center';
      G.floaters.forEach(f=>{
        ctx.globalAlpha = clamp(f.alpha,0,1);
        ctx.fillStyle = '#ffd26b';
        ctx.fillText(f.text, f.x, f.y);
      });
      ctx.restore();
    }

    // ========= Input & Tooltip (basic) =========
    let mouse = {x:0,y:0};
    canvas.addEventListener('mousemove', e=>{
      mouse.x = e.clientX; mouse.y = e.clientY;
    });

    // ========= Startup =========
    // Starter floor to let player begin quickly
    if (G.floors.length===0){
      G.floors.push(makeFloor(0));
    }

    loop();

    // ========= Extra: Keyboard shortcuts =========
    window.addEventListener('keydown', (e)=>{
      if (e.key===' ') { e.preventDefault(); ui.btnStart.click(); }
      if (e.key==='1') { G.speed=1; ui.btnSpeed.textContent='Скорость x1'; }
      if (e.key==='2') { G.speed=2; ui.btnSpeed.textContent='Скорость x2'; }
      if (e.key==='3') { G.speed=4; ui.btnSpeed.textContent='Скорость x4'; }
      if (e.key==='s') save();
      if (e.key==='l') load();
    });

  })();
  </script>
</body>
</html>
